from numpy import *
import sys
def is_float(string):
    '''
    Funkcja sprawdza czy zadany ciąg znaków string może być zamieniony na liczbę typu float

    Parameters
    ----------
    string : str
        Łańcuch znaków do sprawdzenia.

    Returns
    -------
    bool
        True - jeżeli możliwe do zamiany lub False w przecienym wypadku.

    '''
    try:
        float(string)
        return True
    except ValueError:
        return False
class Transformacje:
    def __init__(self, model: str = 'wgs80'):
        if model == "wgs84":
            self.a = 6378137.0 # semimajor_axis
            self.b = 6356752.31424518 # semiminor_axis
        elif model == "grs80":
            self.a = 6378137.0
            self.b = 6356752.31414036
        elif model == "Krasowski":
            self.a = 6378245.0
            self.b = 6356863.01877
        else:
            raise NotImplementedError(f"{model} model not implemented")
        self.flat = (self.a - self.b) / self.a
        self.ecc = sqrt(2 * self.flat - self.flat ** 2) # eccentricity  WGS84:0.0818191910428 
        self.ecc2 = (2 * self.flat - self.flat ** 2) # eccentricity**2
        
    def hirvonen(self, X, Y, Z, output = 'dec_degree'):

            # promien rownoleznika
        p = sqrt(X**2 + Y**2)
            # przyblizona wartosc phi
        phi = arctan(Z/(p*(1-self.ecc2)))

        N = self.a/(1 - self.ecc2 * sin(phi)**2)**(1/2) 
            # obliczamy wartosc N
        while True:
            phi_poprzednie = phi
                #print(phi)
                # obliczenie wysokosci
            h = p/cos(phi_poprzednie) - N
                #obliczenie poprawionej wartosci phi
            phi = arctan(Z/p*((N*(1-self.ecc2)+h)/(N+h))**(-1))
            #warunek
            if abs(phi -phi_poprzednie)<(0.000001/3600*pi/180):
                break
            N= self.a/(1-self.ecc2*sin(phi)**2)**(1/2)
            h= p/cos(phi)-N
            lam= arctan2(Y,X)
        if output == "dec_degree":
            return degrees(phi), degrees(lam), h 
        elif output == "dms":
            phi = self.deg2dms(degrees(phi))
            lam = self.deg2dms(degrees(lam))
            return f"{lat[0]:02d}:{lat[1]:02d}:{lat[2]:.2f}", f"{lon[0]:02d}:{lon[1]:02d}:{lon[2]:.2f}", f"{h:.3f}"
        else:
            raise NotImplementedError(f"{output} - output format not defined") 
       
    def phi_lam_XYZ(self, phi, lam, h, output = 'dec_degree'):
        phi = phi/180 * pi
        lam = lam/180* pi
        N = self.a/(1 - self.ecc2 * sin(phi)**2)**(1/2)
        X = (N+h) * cos(phi) * cos(lam)
        Y = (N+h) * cos(phi) * sin(lam)
        Z = (N*(1-self.ecc2)+h) * sin(phi)
        return X, Y, Z
    def Gk2000(self, lam, phi, lam_0, nr):
        '''
        Funkcja transformująca współrzędne geodezyjne fi i lambda do układu PL2000
        Na początku przekształca współrzędne punktu do układu Gaussa-Krugera, a następnie
        korzystając z matrycy zamienia je na układ PL2000

        Parameters
        ----------
        lam : FLOAT
            Długosc geodezyjna punktu podana w stopniach.
        phi : FLOAT
            Szerokosc geodezyjna punktu podana w stopniach.
        lam_0 : FLOAT
            Połdunik osiowy układu PL2000.
        nr : FLOAT
            Numer południka.

        Returns
        -------
        x2000 : FLOAT
            Współrzędna X w układzie PL2000.
        y2000 : FLOAT
            Współrzędna Y w układzie PL2000.

        '''
        lam = lam/180 * pi
        phi = phi/180 * pi
        lam_0 = lam_0/180 * pi
        
        b2 = self.a**2 * (1-self.ecc2)
        e2p = (self.a **2 - b2)/b2
        n2 = e2p * cos(phi)**2
        t = tan(phi)
        dlam = lam - lam_0
        N = self.a/(1 - self.ecc2 * sin(phi)**2)**(1/2)
        A0 = 1 - (self.ecc2/4) - ((3 * self.ecc2**2)/64) - ((5 * self.ecc2 * self.ecc2**2)/256)
        A2 = 3/8 * (self.ecc2 + self.ecc2**2/4 + 15 * self.ecc2**3/128)
        A4 = 15/256 * (self.ecc2**2 + (3 * self.ecc2 * self.ecc2**2)/4)
        A6 = (35 * self.ecc2 * self.ecc2**2)/3072
        sigma = self.a * (A0 * phi - A2 * sin(2 * phi) + A4 * sin(4 * phi) - A6 * sin(6 * phi))
        xgk = sigma + (dlam**2)/2 * N * sin(phi) * cos(phi) * (1 + (dlam**2)/12 * cos(phi)**2 * (5 - t**2 + 9 * n2 + 4 * n2**2) + (dlam**4)/360 * cos(phi)**4 * (61 - 58 * t**2 + t**4 + 270 * n2 - 330 * n2 * t**2))
        ygk = dlam * N * cos(phi) * (1 + (dlam**2)/6 * cos(phi)**2 * (1 - t**2 + n2) + (dlam**4)/120 * cos(phi)**4 * (5 - 18 * t**2 + t**4 + 14 * n2 - 58 * n2 * t**2))
        x2000 = xgk * 0.999923
        y2000 = ygk * 0.999923 + 500000 + nr * 1000000
        return x2000, y2000
    